

#include <stdio.h>

#include "openssl/evp.h"

#include <string.h>

#include <unistd.h>



#define MAX_LENGTH 16 // A global variable to define max-length







int main (int argc, const char *argv[])

{

	/* This variable is used to store the ciphertext provided to you. Make sure to use the proper format, eg. the hex 'd23a' would be written as {0xd2,0x3a} in C */

	unsigned char ciphertxt[] = {0x20, 0x75, 0x38, 0x6b, 0x75, 0xee, 0xd8, 0xb4, 0xf2, 0xb4, 0xa9, 0xc9, 0xb7, 0x69, 0x67, 0xd0, 0x57, 0xb4, 0xa4, 0x41, 0xd3, 0x49, 0xc1, 0x5d, 0xd4, 0xb8, 0xbf, 0x4b, 0x87, 0x44, 0x5a, 0x9e};



	// This is the plaintext that we are encrypting. Do not change it as it may result in a different ciphertext

	char plaintext[]= "This is a top secret";



	// Pointer fp used to point to the English words file provided along.

	FILE *fp;



	// The initialization Vector is set to 0

	unsigned char iv[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};



	// Output buffer which is the total number of bytes that can be stored in the software output buffer during a write operation is set to 1024 bytes in size

	unsigned char outbuf [1024];



	// Some other variables that are used in the program - output length and temporary length

	int outlen = 0, tmplen = 0;



	/* You may want to declare some additional variables to be used as flags*/

	//assigning an array to the text file

	char fname[] = "/Desktop/words.txt";

	//Open the txt file to 'read' it

	fp = fopen(fname , "r");

	//character variable pointer to output data

	char *dout = "";

	






	// the EVP_CIPHER_CTX is a cryptographic library within openSSL that provides functions for performing symmetric encryption and decryption. 
	EVP_CIPHER_CTX ctx;  // used to initialise the library. ctx refers to the object within the library of EVP_CIPHER_CTX 



	//if (/* Use this statement to check if the words.txt file can be opened in 'r' permission */)

	fp = fopen ("words.txt", "r+");

	//if file cannot be opened or read, print "Error file could not be found".

	if (fp == NULL) 

	{

		/* Print a statement if the above condition is not met */

		printf("Error file could not be found\n");

		return 0;

	}









	char key [MAX_LENGTH]; //array to store the key from the dictionary at 16 

	//when the key is not equal to zero, it will do a for loop to add padding
	//fgets reads one line from fp where the file the is stored
	while (fgets(key, MAX_LENGTH, fp) != NULL)

	{

		for(int i = 0; i < MAX_LENGTH; i++)

		{

			if (key[i] == '\n' || key[i] == 0 ) //when key is less than 16 characters, the extra left part is filled with " "

			{

				for (int j = i; j < strlen(key); j++)

				{

					key[j] = ' ';

				}

				break;

			}

		}



		// Use the EVP library to initialize cipher

		EVP_CIPHER_CTX_init (&ctx);



		// Use the EVP library to encrypt the cipher using advanced encryption standard cipher block chain 128 bits

		EVP_EncryptInit_ex (&ctx, EVP_aes_128_cbc(), NULL, key, iv);



		// Checking to see if EVP_EncryptUpdate is valid or not. the EVP_EncryptUpdate encrypts inl bytes from the buffer in and writes the ecnrypted version to out

		if (!EVP_EncryptUpdate (&ctx, outbuf, &outlen, plaintext, strlen(plaintext)))

		{

			/*Print Out a relevant Error Messege*/

			printf("EVP_EncryptUpdate IS NOT VALID");

			return 0;

		}



		// Buffer passed to EVP_EncryptFinal() must be after data just encrypted to avoid overwriting it



		// Checking to see if !EVP_EncryptFinal_ex is valid or notwhere it ecnrypts the final data which is any data that remains in a partial block.

		if (!EVP_EncryptFinal_ex (&ctx, outbuf + outlen, &tmplen))

		{

			/*Print Out a relevant Error Messege*/

			printf("EVP_EncryptFinal_ex is not valid");

			return 0;

		}



		// called to free any context resources

		outlen += tmplen;

		EVP_CIPHER_CTX_cleanup (&ctx);



		//print curret key and its corresponding ciphertext

		printf("\n");		

		printf ("The key is : %s", key);

		printf("\n");	

	  	printf("The Corresponding Cipher Text Is:  "); 



		/* Use a loop to print out the buffer */

		for(int j = 0; j < outlen; j++) 

		{

			//writen in hexadecimal

			printf(" %0hhx", outbuf[j]);

			

		}

		printf("\n");









						

		/* Judge whether the cipher text generated by this key is match for the provoded one */

		/* As the whole ciphertext cannot be matched at once, use this loop to match it bit by bit */

		for(int q = 0; q < outlen; q++)

																																																						

		{
		//if the output text in the form of an array from the buffer is not equal to the siphertext array, then break, and if it it, the output data (dout) will be equal to the key. 

		if(outbuf[q] != ciphertxt[q])

				{

				break;

				} 

			else if (q == outlen -1 )

			{

				dout = key;

			}

		}

			

			

		

	

			



		//if the generated ciphertext matched with the one provided, then dout should be equal to the key

		if (dout == key )

		{

			printf ("\n*****************************************************\n");

			printf ("\n*****************************************************\n");





			/* Print the key used as the value is now saved in the pointer variable dout*/

			printf("\n");

			printf("The key is: %s \n", dout);





			/* Print the text in the buffer */

			printf("The text in the buffer is:");

			for(int j = 0; j < outlen; j++) 

			{

				/* Use a loop to print out the buffer */

				printf(" %0hhx", outbuf[j]);

			

			}

			printf("\n");





			/* Print the provided ciphertext*/

			int len = strlen(ciphertxt);

			printf("The provided ciphertext:");

			for(int j = 0; j < len; j++) 

			{

				/* Use a loop to print out the buffer */
				//prints the ciphered text 
				printf(" %0hhx", ciphertxt[j]);

			

			}

			printf("\n");





			/* Print the length of */
			// the length of the ciphertext is equal to the stringlength
			len = strlen(ciphertxt);

			printf("The length of the ciphertext is: %d \n", len);

			printf("\n");



			printf ("\n*****************************************************\n");

			printf ("\n*****************************************************\n");

			return 0;

		}

	}

	

	fclose (fp);

	return 0;

}